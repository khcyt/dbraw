const kh_global=Function("return globalThis;")()||Function("return this;")()||Function("return self;")();const as_module=undefined==this;const asWorker="undefined"===typeof window&&"undefined"===typeof process&&self;const cf="kh_js";const mf="kh_ui_lid_esm";kh_global.kh??={};kh_global.kh.context??="undefined"!==typeof window?kh_global.parent==kh_global?"window":"iframe":"undefined"!==typeof process?"node.js":"undefined"!==typeof self?self.name??"worker":"unknown";kh_global.kh.storage??={};const cs=kh_global.kh.storage[cf]??={cf,ms:new Set};const ms=kh_global.kh.storage[mf]??={mf,cs};cs.ms.add(ms);import*as kh_js_e from"/contrib/jsm/kh_earlybird.js";import*as kh_js_c from"/contrib/jsm/kh_classes.js";import*as kh_js_c2 from"/contrib/jsm/kh_classes2.js";const kh_js=Object.assign({...kh_js_e},{...kh_js_c},{...kh_js_c2});const name=MF`${mf}`;const print_level=undefined;import{Logger}from"/contrib/jsm/kh_log.js";const kh_log=new Logger(print_level,(()=>name));export class LevelIndexData{#level_;#index_;#node_;#parent_;constructor({level=-1,index=-1,node,parent}={}){this.#level_=level;this.#index_=index;this.#node_=node;this.#parent_=parent}isValid(){return-1!=this.#level_&&-1!=this.#index_}isBase(){return 0==this.#level_&&0==this.#index_}get level(){return this.#level_}get index(){return this.#index_}get node(){return this.#node_}set node(node){this.#node_=node}get parent(){return this.#parent_}get LevelIndex(){return{level:this.#level_,index:this.#index_}}nextIndex(){if(this.isValid())++this.#index_}previousIndex(){if(this.isValid()&&0!=this.#index_)--this.#index_}nextLevel(){if(this.isValid()){++this.#level_;this.#index_=0}}clone(){return new LevelIndexData(this)}toString(){return`[${this.level}/${this.index}] - ${this.node??"NUL"} => ${this.parent??"NUL"}`}toJSON(){return kh_js.Class.toJSON(this,["level","index","node","parent"])}static Base(node,parent){if(node instanceof LevelIndexData)return node;return new LevelIndexData({level:0,index:0,node,parent})}static nextLevel(level,node){return new LevelIndexData({level:level+1,index:0,node,parent:node})}}export class UniversalIterate{static eMethode=Object.freeze({eM_preOrder:0,eM_levelOrder:1,eM_inversOrder:2,eM_inversLevelOrder:3});static Error=class Error extends kh_js.Error{constructor(){super(...arguments)}};static FIFO=kh_js.FIFO;static LIFO=kh_js.LIFO;static#proceedChilds(lid,c,getOp){let node=lid.node;let newEntry=LevelIndexData.nextLevel(lid.level,node);while(kh_js.isValid(node=getOp(newEntry))){newEntry.node=node;c.push(newEntry.clone());newEntry.nextIndex()}}static async#proceedChildsAsyncWait(lid,c,getOp){let node=lid.node;let newEntry=LevelIndexData.nextLevel(lid.level,node);while(kh_js.isValid(node=await getOp(newEntry))){newEntry.node=node;c.push(newEntry.clone());newEntry.nextIndex()}}static async#proceedChildsAwaitOf(lid,c,getOp){let node=lid.node;let newEntry=LevelIndexData.nextLevel(lid.level,node);const new_nodes=await getOp(newEntry);for await(node of new_nodes){newEntry.node=node;c.push(newEntry.clone());newEntry.nextIndex()}}static#proceedChilds2(lid,c,getOp){const hst=new UniversalIterate.LIFO;UniversalIterate.#proceedChilds(lid,hst,getOp);while(0!=hst.length){c.push(hst.pop())}}static async#proceedChilds2AsyncWait(lid,c,getOp){const hst=new UniversalIterate.LIFO;await UniversalIterate.#proceedChildsAsyncWait(lid,hst,getOp);while(0!=hst.length){c.push(hst.pop())}}static async#proceedChilds2AwaitOf(lid,c,getOp){const hst=new UniversalIterate.LIFO;await UniversalIterate.#proceedChildsAwaitOf(lid,hst,getOp);while(0!=hst.length){c.push(hst.pop())}}static#proceedChilds3(lid,c,getOp,method){const pre_length=c.length;switch(method){case UniversalIterate.eMethode.eM_levelOrder:UniversalIterate.#proceedChilds(lid,c,getOp);break;case UniversalIterate.eMethode.eM_preOrder:case UniversalIterate.eMethode.eM_inversOrder:UniversalIterate.#proceedChilds2(lid,c,getOp);break}return c.length!=pre_length}static async#proceedChilds3AsyncWait(lid,c,getOp,method){const pre_length=c.length;switch(method){case UniversalIterate.eMethode.eM_levelOrder:UniversalIterate.#proceedChildsAsyncWait(lid,c,getOp);break;case UniversalIterate.eMethode.eM_preOrder:case UniversalIterate.eMethode.eM_inversOrder:UniversalIterate.#proceedChilds2AsyncWait(lid,c,getOp);break}return c.length!=pre_length}static async#proceedChilds3AwaitOf(lid,c,getOp,method){const pre_length=c.length;switch(method){case UniversalIterate.eMethode.eM_levelOrder:UniversalIterate.#proceedChildsAwaitOf(lid,c,getOp);break;case UniversalIterate.eMethode.eM_preOrder:case UniversalIterate.eMethode.eM_inversOrder:UniversalIterate.#proceedChilds2AwaitOf(lid,c,getOp);break}return c.length!=pre_length}static#shouldHandle(li,base_cmp,base){return base_cmp||li.node!==base&&li!==base}static FindLevelOrder(base,pred,getOp,base_cmp=true){const qu=new UniversalIterate.FIFO(LevelIndexData.Base(base));while(0!=qu.length){let li=qu.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(pred(li))return li}UniversalIterate.#proceedChilds(li,qu,getOp)}throw new UniversalIterate.Error("FindLevelOrder fails")}static async FindLevelOrderAsyncNonWait(base,pred,getOp,base_cmp=true){const qu=new UniversalIterate.FIFO(LevelIndexData.Base(base));while(0!=qu.length){let li=qu.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(await pred(li))return li}UniversalIterate.#proceedChilds(li,qu,getOp);(await Promise.all(qu.toArray())).forEach(((val,idx)=>qu.at(idx,val)))}throw new UniversalIterate.Error("FindLevelOrder fails")}static async FindLevelOrderAsyncWait(base,pred,getOp,base_cmp=true){const qu=new UniversalIterate.FIFO(LevelIndexData.Base(base));while(0!=qu.length){let li=qu.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(await pred(li))return li}await UniversalIterate.#proceedChildsAsyncWait(li,qu,getOp)}throw new UniversalIterate.Error("FindLevelOrder fails")}static async FindLevelOrderAwaitOf(base,pred,getOp,base_cmp=true){const qu=new UniversalIterate.FIFO(LevelIndexData.Base(base));while(0!=qu.length){let li=qu.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(await pred(li))return li}await UniversalIterate.#proceedChildsAwaitOf(li,qu,getOp)}throw new UniversalIterate.Error("FindLevelOrder fails")}static FindPreOrder(base,pred,getOp,base_cmp=true){const st=new UniversalIterate.LIFO(LevelIndexData.Base(base));while(0!=st.length){let li=st.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(pred(li))return li}UniversalIterate.#proceedChilds2(li,st,getOp)}throw new UniversalIterate.Error("FindPreOrder fails")}static async FindPreOrderAsyncNonWait(base,pred,getOp,base_cmp=true){const st=new UniversalIterate.LIFO(LevelIndexData.Base(base));while(0!=st.length){let li=st.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(await pred(li))return li}UniversalIterate.#proceedChilds2(li,st,getOp);(await Promise.all(st.toArray())).forEach(((val,idx)=>st.at(idx,val)))}throw new UniversalIterate.Error("FindPreOrder fails")}static async FindPreOrderAsyncWait(base,pred,getOp,base_cmp=true){const st=new UniversalIterate.LIFO(LevelIndexData.Base(base));while(0!=st.length){let li=st.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(await pred(li))return li}await UniversalIterate.#proceedChilds2AsyncWait(li,st,getOp)}throw new UniversalIterate.Error("FindPreOrder fails")}static async FindPreOrderAwaitOf(base,pred,getOp,base_cmp=true){const st=new UniversalIterate.LIFO(LevelIndexData.Base(base));while(0!=st.length){let li=st.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(await pred(li))return li}await UniversalIterate.#proceedChilds2AwaitOf(li,st,getOp)}throw new UniversalIterate.Error("FindPreOrder fails")}static FindInOrder(base,pred,getOp,base_cmp=true){throw new UniversalIterate.Error("not implemented")}static FindInversOrder(base,pred,getOp,base_cmp=true){const st=new UniversalIterate.LIFO(LevelIndexData.Base(base));const hs=new Set;while(0!=st.length){let li=st.pop();let process_node=true;if(!hs.has(li.node)){let hst=new UniversalIterate.LIFO;UniversalIterate.#proceedChilds(li,hst,getOp);hs.add(li.node);if(0!=hst.length){st.push(li);while(0!=hst.length)st.push(hst.pop());process_node=false}}if(process_node){if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(pred(li))return li}}}throw new UniversalIterate.Error("FindInversOrder fails")}static async FindInversOrderAwaitOf(base,pred,getOp,base_cmp=true){const st=new UniversalIterate.LIFO(LevelIndexData.Base(base));const hs=new Set;while(0!=st.length){let li=st.pop();let process_node=true;if(!hs.has(li.node)){let hst=new UniversalIterate.LIFO;await UniversalIterate.#proceedChildsAwaitOf(li,hst,getOp);if(0!=hst.length){st.push(li);hs.add(li.node);while(0!=hst.length)st.push(hst.pop());process_node=false}}if(process_node){if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(await pred(li))return li}}}throw new UniversalIterate.Error("FindInversOrder fails")}static FindInversLevelOrder(base,pred,getOp,base_cmp=true){const qu=new UniversalIterate.FIFO(LevelIndexData.Base(base));const st=new UniversalIterate.LIFO;while(0!=qu.length){let li=qu.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){st.push(li)}UniversalIterate.#proceedChilds2(li,qu,getOp)}while(0!=st.length){const li=st.pop();if(pred(li))return li}throw new UniversalIterate.Error("FindInversLevelOrder fails")}static async FindInversLevelOrderAwaitOf(base,pred,getOp,base_cmp=true){const qu=new UniversalIterate.FIFO(LevelIndexData.Base(base));const st=new UniversalIterate.LIFO;while(0!=qu.length){let li=qu.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){st.push(li)}await UniversalIterate.#proceedChilds2AwaitOf(li,qu,getOp)}while(0!=st.length){const li=st.pop();if(await pred(li))return li}throw new UniversalIterate.Error("FindInversLevelOrder fails")}static LevelOrderBarrier(base,pred,getOp,base_cmp=true){const qu=new UniversalIterate.FIFO(LevelIndexData.Base(base));while(0!=qu.length){let li=qu.pop();const x1=li.node===base||li===base;const x2=base_cmp;const x3=!x1||x2?pred(li):false;if(!x3){UniversalIterate.#proceedChilds(li,qu,getOp)}}throw new UniversalIterate.Error("FindLevelOrder fails")}static PreOrderBarrier(base,pred,getOp,base_cmp=true){const st=new UniversalIterate.LIFO(LevelIndexData.Base(base));while(0!=st.length){let li=st.pop();const x1=li.node===base||li===base;const x2=base_cmp;const x3=!x1||x2?pred(li):false;if(!x3){UniversalIterate.#proceedChilds2(li,st,getOp)}}throw new UniversalIterate.Error("FindPreOrder fails")}static LevelOrder(base,pred,getOp,base_cmp=true){try{UniversalIterate.FindLevelOrder(base,(lid=>{pred(lid);return false}),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static PreOrder(base,pred,getOp,base_cmp=true){try{UniversalIterate.FindPreOrder(base,(lid=>{pred(lid);return false}),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static InOrder(base,pred,getOp,base_cmp=true){try{UniversalIterate.FindInOrder(base,(lid=>{pred(lid);return false}),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static InversOrder(base,pred,getOp,base_cmp=true){try{UniversalIterate.FindInversOrder(base,(lid=>{pred(lid);return false}),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static InversLevelOrder(base,pred,getOp,base_cmp=true){try{UniversalIterate.FindInversLevelOrder(base,(lid=>{pred(lid);return false}),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async LevelOrderAsyncNonWait(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindLevelOrderAsyncNonWait(base,(async lid=>Promise.all([pred(lid)]).then((()=>false))),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async LevelOrderAsyncWait(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindLevelOrderAsyncWait(base,(async lid=>Promise.all([pred(lid)]).then((()=>false))),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async LevelOrderAwaitOf(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindLevelOrderAwaitOf(base,(async lid=>Promise.all([pred(lid)]).then((()=>false))),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async PreOrderAsyncNonWait(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindPreOrderAsyncNonWait(base,(async lid=>Promise.all([pred(lid)]).then((()=>false))),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async PreOrderAsyncWait(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindPreOrderAsyncWait(base,(async lid=>Promise.all([pred(lid)]).then((()=>false))),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async PreOrderAwaitOf(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindPreOrderAwaitOf(base,(async lid=>Promise.all([pred(lid)]).then((()=>false))),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static proceedChilds(lid,c,getOp){return UniversalIterate.#proceedChilds(lid,c,getOp)}static proceedChilds2(lid,c,getOp){return UniversalIterate.#proceedChilds2(lid,c,getOp)}}export class UniversalIterator{static eMethode=UniversalIterate.eMethode;#method_;#getOp_;#c_;#hs_;#ic_=0;constructor({method=UniversalIterator.eMethode.eM_preOrder,base,getOp}={}){this.#method_=method;if(-1==Object.values(UniversalIterator.eMethode).indexOf(method))this.#method_=UniversalIterator.eMethode.eM_preOrder;this.#getOp_=getOp;switch(this.#method_){case UniversalIterator.eMethode.eM_preOrder:this.#c_=new UniversalIterate.LIFO(LevelIndexData.Base(base));break;case UniversalIterator.eMethode.eM_levelOrder:this.#c_=new UniversalIterate.FIFO(LevelIndexData.Base(base));break;case UniversalIterator.eMethode.eM_inversOrder:{this.#c_=new UniversalIterate.LIFO(LevelIndexData.Base(base));this.#hs_=new Set;this.preCheck=function(li){kh_log.debug?.(T9`inversOrder preCheck`);let node_added=false;while(1){li??=this.#c_.pop();if(!this.#hs_.has(li.node)){const hc=new UniversalIterate.LIFO;UniversalIterate.proceedChilds(li,hc,this.#getOp_);this.#c_.push(li);this.#hs_.add(li.node);if(!kh_js.isEmpty(hc)){while(0!=hc.length)this.#c_.push(hc.pop());node_added=true;li=undefined}else break}else{this.#c_.push(li);break}}return node_added};break}case UniversalIterator.eMethode.eM_inversLevelOrder:{this.#c_=new UniversalIterate.FIFO(LevelIndexData.Base(base));const hc=new UniversalIterate.LIFO;while(!kh_js.isEmpty(this.#c_)){const li=this.#c_.pop();hc.push(li);UniversalIterate.proceedChilds2(li,this.#c_,this.#getOp_)}this.#c_=hc;break}}}next(){const li=this.#increment();if(-1==this.#method_)return{value:this.#ic_,done:true};else{++this.#ic_;return{value:li,done:false}}}[Symbol.iterator](){return this}get(){kh_log.assert?.(-1!=[UniversalIterator.eMethode.eM_preOrder,UniversalIterator.eMethode.eM_levelOrder,UniversalIterator.eMethode.eM_inversLevelOrder].indexOf(this.#method_),"wrong-usage-of","get()");if(-1==this.#method_||kh_js.isEmpty(this.#c_))return{value:this.#ic_,done:true};else{return{value:this.#c_.peek(),done:false}}}#increment(){if(!kh_js.isEmpty(this.#c_)){let li=this.#c_.pop();switch(this.#method_){case UniversalIterator.eMethode.eM_preOrder:UniversalIterate.proceedChilds2(li,this.#c_,this.#getOp_);break;case UniversalIterator.eMethode.eM_levelOrder:UniversalIterate.proceedChilds(li,this.#c_,this.#getOp_);break;case UniversalIterator.eMethode.eM_inversOrder:{this.preCheck(li);li=this.#c_.pop();break}case UniversalIterator.eMethode.eM_inversLevelOrder:break}return li}else this.#method_=-1}preCheck(){}}export class UniversalIterator2{#method_;#getOp_;#base_;constructor({method=UniversalIterator.eMethode.eM_preOrder,base,getOp}={}){this.#method_=method;if(-1==Object.values(UniversalIterator.eMethode).indexOf(method))this.#method_=UniversalIterator.eMethode.eM_preOrder;this.#base_=base;this.#getOp_=getOp}[Symbol.iterator](){let preCheck=()=>{};let c;switch(this.#method_){case UniversalIterator.eMethode.eM_preOrder:c=new UniversalIterate.LIFO(LevelIndexData.Base(this.#base_));break;case UniversalIterator.eMethode.eM_levelOrder:c=new UniversalIterate.FIFO(LevelIndexData.Base(this.#base_));break;case UniversalIterator.eMethode.eM_inversOrder:{c=new UniversalIterate.LIFO(LevelIndexData.Base(this.#base_));let hs=new Set;preCheck=li=>{kh_log.debug?.(T9`inversOrder preCheck`);let node_added=false;while(1){li??=c.pop();if(!hs.has(li.node)){const hc=new UniversalIterate.LIFO;UniversalIterate.proceedChilds(li,hc,this.#getOp_);c.push(li);hs.add(li.node);if(!kh_js.isEmpty(hc)){while(0!=hc.length)c.push(hc.pop());node_added=true;li=undefined}else break}else{c.push(li);break}}return node_added};break}case UniversalIterator.eMethode.eM_inversLevelOrder:{c=new UniversalIterate.FIFO(LevelIndexData.Base(this.#base_));const hc=new UniversalIterate.LIFO;while(!kh_js.isEmpty(c)){const li=c.pop();hc.push(li);UniversalIterate.proceedChilds2(li,c,this.#getOp_)}c=hc;break}}const increment=()=>{if(!kh_js.isEmpty(c)){let li=c.pop();switch(this.#method_){case UniversalIterator.eMethode.eM_preOrder:UniversalIterate.proceedChilds2(li,c,this.#getOp_);break;case UniversalIterator.eMethode.eM_levelOrder:UniversalIterate.proceedChilds(li,c,this.#getOp_);break;case UniversalIterator.eMethode.eM_inversOrder:{preCheck(li);li=c.pop();break}case UniversalIterator.eMethode.eM_inversLevelOrder:break}return li}else this.#method_=-1};let i=0;return{next:()=>{const li=increment();if(-1==this.#method_)return{value:i,done:true};else{++i;return{value:li,done:false}}}}}}export function bdt(base,getOp=getter.obj(),prefix=""){UniversalIterate.LevelOrder(base,(lid=>{const node=0==lid.level?lid.node:lid.parent?.[lid.node];if(!kh_js.isPlainObject(node))return;if(kh_js.isEmpty("function"==typeof node.parent?node.parent():node.parent)&&kh_js.isEmpty("function"==typeof node.parentNode?node.parentNode():node.parentNode)){function defProp(name,value,getter=false){Object.defineProperty(node,name,{enumreable:false,[getter?"get":"value"]:getter?()=>value:value})}const P=(strings,...keys)=>keys.map(((key,i)=>strings[i]+prefix+(key?.toString?.()||JSON.stringify(key)))).join("")+strings[strings.length-1];const name=0==lid.level?"/":lid.node;defProp(P`${"parent"}`,0==lid.level?undefined:lid.parent,true);defProp(P`${"root"}`,0==lid.level?()=>node:()=>node[P`${"parent"}`]?.[P`${"root"}`]?.());defProp(P`${"name_"}`,(()=>name));defProp(P`${"isRoot"}`,(()=>0==lid.level));defProp(P`${"pathFromRoot"}`,(()=>[...node[P`${"parent"}`]?.[P`${"pathFromRoot"}`]()??[],node]));defProp(P`${"pathFromRootS"}`,(()=>{if(node[P`${"isRoot"}`]())return node[P`${"name_"}`]();else return node[P`${"pathFromRoot"}`]().map((n=>n[P`${"name_"}`]())).join("/").substring(1)}));defProp(P`${"child_"}`,new Set,true);defProp(P`${"child"}`,(function(child,add=true){if(add)node[P`${"child_"}`].add(child);else node[P`${"child_"}`].delete(child)}));node[P`${"parent"}`]?.[P`${"child"}`](node);defProp(P`${"childs"}`,(()=>Array.from(node[P`${"child_"}`])??[]));lid.node=node}}),getOp,true)}export const getter={dom(with_text_nodes=false){const select_childs=with_text_nodes?node=>node.childNodes:node=>node.children;return lid=>select_childs(lid.parent)?.[lid.index]},obj(){return lid=>!kh_js.isPlainObject(lid.parent)?undefined:Object.keys(lid.parent)[lid.index]}};kh_global.LoadedScripts?.get(mf).resolve(ms);