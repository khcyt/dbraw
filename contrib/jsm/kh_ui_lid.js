const kh_global=Function("return globalThis;")()||Function("return this;")()||Function("return self;")();const as_module=undefined==this;const asWorker="undefined"===typeof kh_global.window&&"undefined"===typeof kh_global.process&&kh_global.self;const cf="kh_js";const mf="kh_ui_lid_esm";kh_global.kh??={};kh_global.kh.context??="undefined"!==typeof kh_global.window?kh_global.parent==kh_global?"window":"iframe":"undefined"!==typeof kh_global.process?"node.js":"undefined"!==typeof kh_global.self?kh_global.self.name??"worker":"unknown";kh_global.kh.storage??={};const cs=kh_global.kh.storage[cf]??={cf,ms:new Set};const ms=kh_global.kh.storage[mf]??={mf,cs};cs.ms.add(ms);import{isValid,isEmpty,isPlainObject}from"/contrib/jsm/kh_earlybird.js";import{Error as khjsError,Class}from"/contrib/jsm/kh_classes.js";import{FIFO,LIFO}from"/contrib/jsm/kh_classes2.js";const name=kh_global.MF`${mf}`;const print_level=undefined;import{Logger}from"/contrib/jsm/kh_log.js";const kh_log=new Logger(print_level,()=>name);export class LevelIndexData{#level_=-1;#index_=-1;#node_=undefined;#parent_;constructor({level=-1,index=-1,node,parent}={}){this.#level_=level;this.#index_=index;this.#node_=node;this.#parent_=parent}isValid(){return-1!=this.#level_&&-1!=this.#index_}isBase(){return 0==this.#level_&&0==this.#index_}get level(){return this.#level_}get index(){return this.#index_}get node(){return this.#node_}set node(node){this.#node_=node}get parent(){return this.#parent_}get LevelIndex(){return{level:this.#level_,index:this.#index_}}nextIndex(){if(this.isValid())++this.#index_}previousIndex(){if(this.isValid()&&0!=this.#index_)--this.#index_}nextLevel(){if(this.isValid()){++this.#level_;this.#index_=0}}clone(){return new LevelIndexData(this)}toString(){return`[${this.level}/${this.index}] - ${this.node??"NUL"} => ${this.parent??"NUL"}`}toJSON(){return Class.toJSON(this,["level","index","node","parent"])}static Base(node,parent=undefined){if(node instanceof LevelIndexData)return node;return new LevelIndexData({level:0,index:0,node,parent})}static nextLevel(level,node){return new LevelIndexData({level:level+1,index:0,node,parent:node})}}var eMethode;(function(eMethode){eMethode[eMethode["eM_preOrder"]=0]="eM_preOrder";eMethode[eMethode["eM_levelOrder"]=1]="eM_levelOrder";eMethode[eMethode["eM_inversOrder"]=2]="eM_inversOrder";eMethode[eMethode["eM_inversLevelOrder"]=3]="eM_inversLevelOrder";eMethode[eMethode["eM_noop"]=-1]="eM_noop"})(eMethode||(eMethode={}));export class UniversalIterate{static Error=class Error extends khjsError{constructor(...argz){super(...argz)}};static#proceedChilds(lid,c,getOp){let node=lid.node;let newEntry=LevelIndexData.nextLevel(lid.level,node);while(isValid(node=getOp(newEntry))){newEntry.node=node;c.push(newEntry.clone());newEntry.nextIndex()}}static async#proceedChildsAsyncWait(lid,c,getOp){let node=lid.node;let newEntry=LevelIndexData.nextLevel(lid.level,node);while(isValid(node=await getOp(newEntry))){newEntry.node=node;c.push(newEntry.clone());newEntry.nextIndex()}}static async#proceedChildsAwaitOf(lid,c,getOp){let node=lid.node;let newEntry=LevelIndexData.nextLevel(lid.level,node);const new_nodes=await getOp(newEntry);for await(node of new_nodes){newEntry.node=node;c.push(newEntry.clone());newEntry.nextIndex()}}static#proceedChilds2(lid,c,getOp){const hst=new LIFO;UniversalIterate.#proceedChilds(lid,hst,getOp);while(0!=hst.length){c.push(hst.pop())}}static async#proceedChilds2AsyncWait(lid,c,getOp){const hst=new LIFO;await UniversalIterate.#proceedChildsAsyncWait(lid,hst,getOp);while(0!=hst.length){c.push(hst.pop())}}static async#proceedChilds2AwaitOf(lid,c,getOp){const hst=new LIFO;await UniversalIterate.#proceedChildsAwaitOf(lid,hst,getOp);while(0!=hst.length){c.push(hst.pop())}}static#proceedChilds3(lid,c,getOp,method){const pre_length=c.length;switch(method){case eMethode.eM_levelOrder:UniversalIterate.#proceedChilds(lid,c,getOp);break;case eMethode.eM_preOrder:case eMethode.eM_inversOrder:UniversalIterate.#proceedChilds2(lid,c,getOp);break}return c.length!=pre_length}static async#proceedChilds3AsyncWait(lid,c,getOp,method){const pre_length=c.length;switch(method){case eMethode.eM_levelOrder:UniversalIterate.#proceedChildsAsyncWait(lid,c,getOp);break;case eMethode.eM_preOrder:case eMethode.eM_inversOrder:UniversalIterate.#proceedChilds2AsyncWait(lid,c,getOp);break}return c.length!=pre_length}static async#proceedChilds3AwaitOf(lid,c,getOp,method){const pre_length=c.length;switch(method){case eMethode.eM_levelOrder:UniversalIterate.#proceedChildsAwaitOf(lid,c,getOp);break;case eMethode.eM_preOrder:case eMethode.eM_inversOrder:UniversalIterate.#proceedChilds2AwaitOf(lid,c,getOp);break}return c.length!=pre_length}static#shouldHandle(lid,base_cmp,base){return base_cmp||lid.node!==base&&lid!==base}static FindLevelOrder(base,pred,getOp,base_cmp=true){const qu=new FIFO(LevelIndexData.Base(base));while(0!=qu.length){let li=qu.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(pred(li))return li}UniversalIterate.#proceedChilds(li,qu,getOp)}throw new UniversalIterate.Error("FindLevelOrder fails")}static async FindLevelOrderAsyncNonWait(base,pred,getOp,base_cmp=true){const qu=new FIFO(LevelIndexData.Base(base));while(0!=qu.length){let li=qu.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(await pred(li))return li}UniversalIterate.#proceedChilds(li,qu,getOp);(await Promise.all(qu.toArray())).forEach((val,idx)=>qu.at(idx,val))}throw new UniversalIterate.Error("FindLevelOrder fails")}static async FindLevelOrderAsyncWait(base,pred,getOp,base_cmp=true){const qu=new FIFO(LevelIndexData.Base(base));while(0!=qu.length){let li=qu.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(await pred(li))return li}await UniversalIterate.#proceedChildsAsyncWait(li,qu,getOp)}throw new UniversalIterate.Error("FindLevelOrder fails")}static async FindLevelOrderAwaitOf(base,pred,getOp,base_cmp=true){const qu=new FIFO(LevelIndexData.Base(base));while(0!=qu.length){let li=qu.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(await pred(li))return li}await UniversalIterate.#proceedChildsAwaitOf(li,qu,getOp)}throw new UniversalIterate.Error("FindLevelOrder fails")}static FindPreOrder(base,pred,getOp,base_cmp=true){const st=new LIFO(LevelIndexData.Base(base));while(0!=st.length){let li=st.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(pred(li))return li}UniversalIterate.#proceedChilds2(li,st,getOp)}throw new UniversalIterate.Error("FindPreOrder fails")}static async FindPreOrderAsyncNonWait(base,pred,getOp,base_cmp=true){const st=new LIFO(LevelIndexData.Base(base));while(0!=st.length){let li=st.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(await pred(li))return li}UniversalIterate.#proceedChilds2(li,st,getOp);(await Promise.all(st.toArray())).forEach((val,idx)=>st.at(idx,val))}throw new UniversalIterate.Error("FindPreOrder fails")}static async FindPreOrderAsyncWait(base,pred,getOp,base_cmp=true){const st=new LIFO(LevelIndexData.Base(base));while(0!=st.length){let li=st.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(await pred(li))return li}await UniversalIterate.#proceedChilds2AsyncWait(li,st,getOp)}throw new UniversalIterate.Error("FindPreOrder fails")}static async FindPreOrderAwaitOf(base,pred,getOp,base_cmp=true){const st=new LIFO(LevelIndexData.Base(base));while(0!=st.length){let li=st.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(await pred(li))return li}await UniversalIterate.#proceedChilds2AwaitOf(li,st,getOp)}throw new UniversalIterate.Error("FindPreOrder fails")}static FindInOrder(base,pred,getOp,base_cmp=true){throw new UniversalIterate.Error("not implemented")}static FindInversOrder(base,pred,getOp,base_cmp=true){const st=new LIFO(LevelIndexData.Base(base));const hs=new Set;while(0!=st.length){let li=st.pop();let process_node=true;if(!hs.has(li.node)){let hst=new LIFO;UniversalIterate.#proceedChilds(li,hst,getOp);hs.add(li.node);if(0!=hst.length){st.push(li);while(0!=hst.length)st.push(hst.pop());process_node=false}}if(process_node){if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(pred(li))return li}}}throw new UniversalIterate.Error("FindInversOrder fails")}static async FindInversOrderAwaitOf(base,pred,getOp,base_cmp=true){const st=new LIFO(LevelIndexData.Base(base));const hs=new Set;while(0!=st.length){let li=st.pop();let process_node=true;if(!hs.has(li.node)){let hst=new LIFO;await UniversalIterate.#proceedChildsAwaitOf(li,hst,getOp);if(0!=hst.length){st.push(li);hs.add(li.node);while(0!=hst.length)st.push(hst.pop());process_node=false}}if(process_node){if(UniversalIterate.#shouldHandle(li,base_cmp,base)){if(await pred(li))return li}}}throw new UniversalIterate.Error("FindInversOrder fails")}static FindInversLevelOrder(base,pred,getOp,base_cmp=true){const qu=new FIFO(LevelIndexData.Base(base));const st=new LIFO;while(0!=qu.length){let li=qu.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){st.push(li)}UniversalIterate.#proceedChilds2(li,qu,getOp)}while(0!=st.length){let li=st.pop();if(pred(li))return li}throw new UniversalIterate.Error("FindInversLevelOrder fails")}static async FindInversLevelOrderAwaitOf(base,pred,getOp,base_cmp=true){const qu=new FIFO(LevelIndexData.Base(base));const st=new LIFO;while(0!=qu.length){let li=qu.pop();if(UniversalIterate.#shouldHandle(li,base_cmp,base)){st.push(li)}await UniversalIterate.#proceedChilds2AwaitOf(li,qu,getOp)}while(0!=st.length){let li=st.pop();if(await pred(li))return li}throw new UniversalIterate.Error("FindInversLevelOrder fails")}static LevelOrderBarrier(base,pred,getOp,base_cmp=true){const qu=new FIFO(LevelIndexData.Base(base));while(0!=qu.length){let li=qu.pop();const x1=li.node===base||li===base;const x2=base_cmp;const x3=!x1||x2?pred(li):false;if(!x3){UniversalIterate.#proceedChilds(li,qu,getOp)}}throw new UniversalIterate.Error("FindLevelOrder fails")}static PreOrderBarrier(base,pred,getOp,base_cmp=true){const st=new LIFO(LevelIndexData.Base(base));while(0!=st.length){let li=st.pop();const x1=li.node===base||li===base;const x2=base_cmp;const x3=!x1||x2?pred(li):false;if(!x3){UniversalIterate.#proceedChilds2(li,st,getOp)}}throw new UniversalIterate.Error("FindPreOrder fails")}static LevelOrder(base,pred,getOp,base_cmp=true){try{UniversalIterate.FindLevelOrder(base,lid=>{pred(lid);return false},getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static PreOrder(base,pred,getOp,base_cmp=true){try{UniversalIterate.FindPreOrder(base,lid=>{pred(lid);return false},getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static InOrder(base,pred,getOp,base_cmp=true){try{UniversalIterate.FindInOrder(base,lid=>{pred(lid);return false},getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static InversOrder(base,pred,getOp,base_cmp=true){try{UniversalIterate.FindInversOrder(base,lid=>{pred(lid);return false},getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static InversLevelOrder(base,pred,getOp,base_cmp=true){try{UniversalIterate.FindInversLevelOrder(base,lid=>{pred(lid);return false},getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async LevelOrderAsyncNonWait(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindLevelOrderAsyncNonWait(base,async lid=>Promise.all([pred(lid)]).then(()=>false),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async LevelOrderAsyncWait(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindLevelOrderAsyncWait(base,async lid=>Promise.all([pred(lid)]).then(()=>false),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async LevelOrderAwaitOf(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindLevelOrderAwaitOf(base,async lid=>Promise.all([pred(lid)]).then(()=>false),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async PreOrderAsyncNonWait(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindPreOrderAsyncNonWait(base,async lid=>Promise.all([pred(lid)]).then(()=>false),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async PreOrderAsyncWait(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindPreOrderAsyncWait(base,async lid=>Promise.all([pred(lid)]).then(()=>false),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async PreOrderAwaitOf(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindPreOrderAwaitOf(base,async lid=>Promise.all([pred(lid)]).then(()=>false),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static proceedChilds(lid,c,getOp){return UniversalIterate.#proceedChilds(lid,c,getOp)}static proceedChilds2(lid,c,getOp){return UniversalIterate.#proceedChilds2(lid,c,getOp)}}export class UniversalIterator{#method_;#getOp_;#c_;#hs_;#ic_=0;constructor({method=eMethode.eM_preOrder,base,getOp}={}){this.#method_=method;if(-1==Object.values(eMethode).indexOf(method))this.#method_=eMethode.eM_preOrder;this.#getOp_=getOp;switch(this.#method_){case eMethode.eM_preOrder:this.#c_=new LIFO(LevelIndexData.Base(base));break;case eMethode.eM_levelOrder:this.#c_=new FIFO(LevelIndexData.Base(base));break;case eMethode.eM_inversOrder:{this.#c_=new LIFO(LevelIndexData.Base(base));this.#hs_=new Set;this.preCheck=function(li){kh_log.debug?.(T9`inversOrder preCheck`);let node_added=false;while(1){li??=this.#c_.pop();if(!this.#hs_.has(li.node)){const hc=new LIFO;UniversalIterate.proceedChilds(li,hc,this.#getOp_);this.#c_.push(li);this.#hs_.add(li.node);if(!isEmpty(hc)){while(0!=hc.length)this.#c_.push(hc.pop());node_added=true;li=undefined}else break}else{this.#c_.push(li);break}}return node_added};break}case eMethode.eM_inversLevelOrder:{this.#c_=new FIFO(LevelIndexData.Base(base));const hc=new LIFO;while(!isEmpty(this.#c_)){const li=this.#c_.pop();hc.push(li);UniversalIterate.proceedChilds2(li,this.#c_,this.#getOp_)}this.#c_=hc;break}}}next(){const li=this.#increment();if(-1==this.#method_)return{value:this.#ic_,done:true};else{++this.#ic_;return{value:li,done:false}}}[Symbol.iterator](){return this}get(){kh_log.assert?.(-1!=[eMethode.eM_preOrder,eMethode.eM_levelOrder,eMethode.eM_inversLevelOrder].indexOf(this.#method_),"wrong-usage-of","get()");if(-1==this.#method_||isEmpty(this.#c_))return{value:this.#ic_,done:true};else{return{value:this.#c_.peek(),done:false}}}#increment(){if(!isEmpty(this.#c_)){let li=this.#c_.pop();switch(this.#method_){case eMethode.eM_preOrder:UniversalIterate.proceedChilds2(li,this.#c_,this.#getOp_);break;case eMethode.eM_levelOrder:UniversalIterate.proceedChilds(li,this.#c_,this.#getOp_);break;case eMethode.eM_inversOrder:{this.preCheck(li);li=this.#c_.pop();break}case eMethode.eM_inversLevelOrder:break}return li}else this.#method_=-1}preCheck(li){}}export class UniversalIterator2{#method_;#getOp_;#base_;constructor({method=eMethode.eM_preOrder,base,getOp}={}){this.#method_=method;if(-1==Object.values(eMethode).indexOf(method))this.#method_=eMethode.eM_preOrder;this.#base_=base;this.#getOp_=getOp}[Symbol.iterator](){let preCheck=li=>true;let c;switch(this.#method_){case eMethode.eM_preOrder:c=new LIFO(LevelIndexData.Base(this.#base_));break;case eMethode.eM_levelOrder:c=new FIFO(LevelIndexData.Base(this.#base_));break;case eMethode.eM_inversOrder:{c=new LIFO(LevelIndexData.Base(this.#base_));let hs=new Set;preCheck=li=>{kh_log.debug?.(T9`inversOrder preCheck`);let node_added=false;while(1){li??=c.pop();if(!hs.has(li.node)){const hc=new LIFO;UniversalIterate.proceedChilds(li,hc,this.#getOp_);c.push(li);hs.add(li.node);if(!isEmpty(hc)){while(0!=hc.length)c.push(hc.pop());node_added=true;li=undefined}else break}else{c.push(li);break}}return node_added};break}case eMethode.eM_inversLevelOrder:{c=new FIFO(LevelIndexData.Base(this.#base_));const hc=new LIFO;while(!isEmpty(c)){const li=c.pop();hc.push(li);UniversalIterate.proceedChilds2(li,c,this.#getOp_)}c=hc;break}}const increment=()=>{if(!isEmpty(c)){let li=c.pop();switch(this.#method_){case eMethode.eM_preOrder:UniversalIterate.proceedChilds2(li,c,this.#getOp_);break;case eMethode.eM_levelOrder:UniversalIterate.proceedChilds(li,c,this.#getOp_);break;case eMethode.eM_inversOrder:{preCheck(li);li=c.pop();break}case eMethode.eM_inversLevelOrder:break}return li}else this.#method_=eMethode.eM_noop};let i=0;return{next:()=>{const li=increment();if(-1==this.#method_)return{value:i,done:true};else{++i;return{value:li,done:false}}}}}}export function bdt(base,getOp=getter.obj(),prefix=""){UniversalIterate.LevelOrder(base,lid=>{const node=0==lid.level?lid.node:lid.parent?.[lid.node];if(!isPlainObject(node))return false;if(isEmpty(Function.isFunction(node.parent)?node.parent():node.parent)&&isEmpty(Function.isFunction(node.parentNode)?node.parentNode():node.parentNode)){function defProp(name,value,getter=false){Object.defineProperty(node,name,{enumerable:false,[getter?"get":"value"]:getter?()=>value:value})}const P=(strings,...keys)=>keys.map((key,i)=>strings[i]+prefix+(key?.toString?.()||JSON.stringify(key))).join("")+strings[strings.length-1];const name=0==lid.level?"/":lid.node;defProp(P`${"parent"}`,0==lid.level?undefined:lid.parent,true);defProp(P`${"root"}`,0==lid.level?()=>node:()=>node[P`${"parent"}`]?.[P`${"root"}`]?.());defProp(P`${"name_"}`,()=>name);defProp(P`${"isRoot"}`,()=>0==lid.level);defProp(P`${"pathFromRoot"}`,()=>[...node[P`${"parent"}`]?.[P`${"pathFromRoot"}`]()??[],node]);defProp(P`${"pathFromRootS"}`,()=>{if(node[P`${"isRoot"}`]())return node[P`${"name_"}`]();else return node[P`${"pathFromRoot"}`]().map(n=>n[P`${"name_"}`]()).join("/").substring(1)});defProp(P`${"child_"}`,new Set,true);defProp(P`${"child"}`,function(child,add=true){if(add)node[P`${"child_"}`].add(child);else node[P`${"child_"}`].delete(child)});node[P`${"parent"}`]?.[P`${"child"}`](node);defProp(P`${"childs"}`,()=>Array.from(node[P`${"child_"}`])??[]);lid.node=node}},getOp,true)}export const getter={dom(with_text_nodes=false){const select_childs=with_text_nodes?node=>node.childNodes:node=>node.children;return lid=>select_childs(lid.parent)?.[lid.index]},obj(){return lid=>!isPlainObject(lid.parent)?undefined:Object.keys(lid.parent)[lid.index]}};kh_global.LoadedScripts?.get(mf).resolve(ms);