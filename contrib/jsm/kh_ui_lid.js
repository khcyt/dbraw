const kh_global=Function("return globalThis;")()||Function("return this;")()||Function("return self;")();const as_module=undefined==this;const asWorker="undefined"===typeof window&&"undefined"===typeof process&&self;const cf="kh_js";const mf="kh_ui_lid_esm";kh_global.kh??={};kh_global.kh.context??="undefined"!==typeof window?kh_global.parent==kh_global?"window":"iframe":"undefined"!==typeof process?"node.js":"undefined"!==typeof self?self.name??"worker":"unknown";kh_global.kh.storage??={};const cs=kh_global.kh.storage[cf]??={cf,ms:new Set};const ms=kh_global.kh.storage[mf]??={mf,cs};cs.ms.add(ms);import*as kh_js_e from"/contrib/jsm/kh_earlybird.js";import*as kh_js_c from"/contrib/jsm/kh_classes.js";import*as kh_js_c2 from"/contrib/jsm/kh_classes2.js";const kh_js=Object.assign({...kh_js_e},{...kh_js_c},{...kh_js_c2});const name=MF`${mf}`;const print_level=undefined;import{Logger}from"/contrib/jsm/kh_log.js";const kh_log=new Logger(print_level,(()=>name));export class LevelIndexData{#level_;#index_;#node_;#parent_;constructor({level=-1,index=-1,node,parent}={}){this.#level_=level;this.#index_=index;this.#node_=node;this.#parent_=parent}isValid(){return-1!=this.#level_&&-1!=this.#index_}isBase(){return 0==this.#level_&&0==this.#index_}get level(){return this.#level_}get index(){return this.#index_}get node(){return this.#node_}set node(node){this.#node_=node}get parent(){return this.#parent_}get LevelIndex(){return{level:this.#level_,index:this.#index_}}nextIndex(){if(this.isValid())++this.#index_}previousIndex(){if(this.isValid()&&0!=this.#index_)--this.#index_}nextLevel(){if(this.isValid()){++this.#level_;this.#index_=0}}clone(){return new LevelIndexData(this)}toString(){return`[${this.level}/${this.index}] - ${this.node??"NUL"} => ${this.parent??"NUL"}`}toJSON(){return kh_js.Class.toJSON(this,["level","index","node","parent"])}static Base(node,parent){return new LevelIndexData({level:0,index:0,node,parent})}static nextLevel(level,node){return new LevelIndexData({level:level+1,index:0,node,parent:node})}}export class UniversalIterate{static eMethode=Object.freeze({eM_preOrder:0,eM_levelOrder:1,eM_inversOrder:2});static Error=class Error extends kh_js.Error{constructor(){super(...arguments)}};static FIFO=kh_js.FIFO;static LIFO=kh_js.LIFO;static#proceedChilds(lid,c,getOp){let node=lid.node;let newEntry=LevelIndexData.nextLevel(lid.level,node);while(kh_js.isValid(node=getOp(newEntry))){newEntry.node=node;c.push(newEntry.clone());newEntry.nextIndex()}}static async#proceedChildsAsyncWait(lid,c,getOp){let node=lid.node;let newEntry=LevelIndexData.nextLevel(lid.level,node);while(kh_js.isValid(node=await getOp(newEntry))){newEntry.node=node;c.push(newEntry.clone());newEntry.nextIndex()}}static#proceedChilds2(lid,c,getOp){const hst=new UniversalIterate.LIFO;UniversalIterate.#proceedChilds(lid,hst,getOp);while(0!=hst.length){c.push(hst.pop())}}static async#proceedChilds2AsyncWait(lid,c,getOp){const hst=new UniversalIterate.LIFO;await UniversalIterate.#proceedChildsAsyncWait(lid,hst,getOp);while(0!=hst.length){c.push(hst.pop())}}static#proceedChilds3(lid,c,getOp,method){const pre_length=c.length;switch(method){case UniversalIterate.eMethode.eM_levelOrder:UniversalIterate.#proceedChilds(lid,c,getOp);break;case UniversalIterate.eMethode.eM_preOrder:case UniversalIterate.eMethode.eM_inversOrder:UniversalIterate.#proceedChilds2(lid,c,getOp);break}return c.length!=pre_length}static async#proceedChilds3AsyncWait(lid,c,getOp,method){const pre_length=c.length;switch(method){case UniversalIterate.eMethode.eM_levelOrder:UniversalIterate.#proceedChildsAsyncWait(lid,c,getOp);break;case UniversalIterate.eMethode.eM_preOrder:case UniversalIterate.eMethode.eM_inversOrder:UniversalIterate.#proceedChilds2AsyncWait(lid,c,getOp);break}return c.length!=pre_length}static FindLevelOrder(base,pred,getOp,base_cmp=true){const qu=new UniversalIterate.FIFO(LevelIndexData.Base(base));while(0!=qu.length){let li=qu.pop();if(base_cmp||li.node!=base){if(pred(li))return li}UniversalIterate.#proceedChilds(li,qu,getOp)}throw new UniversalIterate.Error("FindLevelOrder fails")}static async FindLevelOrderAsyncNonWait(base,pred,getOp,base_cmp=true){const qu=new UniversalIterate.FIFO(LevelIndexData.Base(base));while(0!=qu.length){let li=qu.pop();if(base_cmp||li.node!=base){if(pred(li))return li}UniversalIterate.#proceedChilds(li,qu,getOp);(await Promise.all(qu.toArray())).forEach(((val,idx)=>qu.at(idx,val)))}throw new UniversalIterate.Error("FindLevelOrder fails")}static async FindLevelOrderAsyncWait(base,pred,getOp,base_cmp=true){const qu=new UniversalIterate.FIFO(LevelIndexData.Base(base));while(0!=qu.length){let li=qu.pop();if(base_cmp||li.node!=base){if(pred(li))return li}await UniversalIterate.#proceedChildsAsyncWait(li,qu,getOp)}throw new UniversalIterate.Error("FindLevelOrder fails")}static FindPreOrder(base,pred,getOp,base_cmp=true){const st=new UniversalIterate.LIFO(LevelIndexData.Base(base));while(0!=st.length){let li=st.pop();if(base_cmp||li.node!=base){if(pred(li))return li}UniversalIterate.#proceedChilds2(li,st,getOp)}throw new UniversalIterate.Error("FindPreOrder fails")}static async FindPreOrderAsyncNonWait(base,pred,getOp,base_cmp=true){const st=new UniversalIterate.LIFO(LevelIndexData.Base(base));while(0!=st.length){let li=st.pop();if(base_cmp||li.node!=base){if(pred(li))return li}UniversalIterate.#proceedChilds2(li,st,getOp);(await Promise.all(st.toArray())).forEach(((val,idx)=>st.at(idx,val)))}throw new UniversalIterate.Error("FindPreOrder fails")}static async FindPreOrderAsyncWait(base,pred,getOp,base_cmp=true){const st=new UniversalIterate.LIFO(LevelIndexData.Base(base));while(0!=st.length){let li=st.pop();if(base_cmp||li.node!=base){if(pred(li))return li}await UniversalIterate.#proceedChilds2AsyncWait(li,st,getOp)}throw new UniversalIterate.Error("FindPreOrder fails")}static FindInOrder(base,pred,getOp,base_cmp=true){throw new UniversalIterate.Error("not implemented")}static FindInversOrder(base,pred,getOp,base_cmp=true){const st=new UniversalIterate.LIFO(LevelIndexData.Base(base));const hs=new Set;while(0!=st.length){let li=st.pop();let process_node=true;if(!hs.has(li.node)){let hst=new UniversalIterate.LIFO;UniversalIterate.#proceedChilds(li,hst,getOp);if(0!=hst.length){st.push(li);hs.add(li.node);while(0!=hst.length)st.push(hst.pop());process_node=false}}if(process_node){if(base_cmp||li.node!=base){if(pred(li))return li}}}throw new UniversalIterate.Error("FindInversOrder fails")}static FindInversLevelOrder(base,pred,getOp,base_cmp=true){const qu=new UniversalIterate.FIFO(LevelIndexData.Base(base));const st=new UniversalIterate.LIFO;while(0!=qu.length){let li=qu.pop();if(base_cmp||li.node!=base){st.push(li)}UniversalIterate.#proceedChilds2(li,qu,getOp)}while(0!=st.length){const li=st.pop();if(pred(li))return li}throw new UniversalIterate.Error("FindInversLevelOrder fails")}static LevelOrderBarrier(base,pred,getOp,base_cmp=true){const qu=new UniversalIterate.FIFO(LevelIndexData.Base(base));while(0!=qu.length){let li=qu.pop();const x1=li.node==base;const x2=base_cmp;const x3=!x1||x2?pred(li):false;if(!x3){UniversalIterate.#proceedChilds(li,qu,getOp)}}throw new UniversalIterate.Error("FindLevelOrder fails")}static PreOrderBarrier(base,pred,getOp,base_cmp=true){const st=new UniversalIterate.LIFO(LevelIndexData.Base(base));while(0!=st.length){let li=st.pop();const x1=li.node==base;const x2=base_cmp;const x3=!x1||x2?pred(li):false;if(!x3){UniversalIterate.#proceedChilds2(li,st,getOp)}}throw new UniversalIterate.Error("FindPreOrder fails")}static LevelOrder(base,pred,getOp,base_cmp=true){try{UniversalIterate.FindLevelOrder(base,(lid=>{pred(lid);return false}),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static PreOrder(base,pred,getOp,base_cmp=true){try{UniversalIterate.FindPreOrder(base,(lid=>{pred(lid);return false}),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static InOrder(base,pred,getOp,base_cmp=true){try{UniversalIterate.FindInOrder(base,(lid=>{pred(lid);return false}),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static InversOrder(base,pred,getOp,base_cmp=true){try{UniversalIterate.FindInversOrder(base,(lid=>{pred(lid);return false}),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static InversLevelOrder(base,pred,getOp,base_cmp=true){try{UniversalIterate.FindInversLevelOrder(base,(lid=>{pred(lid);return false}),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async LevelOrderAsyncNonWait(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindLevelOrderAsyncNonWait(base,(lid=>{pred(lid);return false}),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async LevelOrderAsyncWait(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindLevelOrderAsyncWait(base,(lid=>{pred(lid);return false}),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async PreOrderAsyncNonWait(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindPreOrderAsyncNonWait(base,(lid=>{pred(lid);return false}),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}static async PreOrderAsyncWait(base,pred,getOp,base_cmp=true){try{await UniversalIterate.FindPreOrderAsyncWait(base,(lid=>{pred(lid);return false}),getOp,base_cmp)}catch(error){if(!(error instanceof UniversalIterate.Error))throw error}}}kh_global.LoadedScripts?.get(mf).resolve(ms);